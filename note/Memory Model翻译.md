中文翻译：

https://jasonkayzk.github.io/2022/10/26/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/





### Memory Model

Go 中内存模型的定义与 `Hans-J. Boehm` 和 `Sarita V. Adve` 在2008年发表在 PLDI 上的论文 [Foundations of the C++ Concurrency Memory Model](https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf) 内容非常接近；同时，关于禁止 data-race（`data-race-free`）和保证在禁止数据竞争（`race-free`）程序中顺序一致性的描述和论文内容完全一致。

内存模型描述了代码执行的基本需求：Go 的执行是由大量 goroutine 执行组成，当然最终这些执行都会转化为内存操作；

一个"内存操作"通过以下4个细节来建模（内存模型定义）：

- 内存操作类型

  表示这个内存操作是：普通读数据、普通写数据、或者是一个同步操作，如：原子数据访问、互斥锁操作、Channel 操作等；

- 内存操作本身在代码中的位置

- 被访问的内存位置或变量

- 内存操作所读取或写入的值

有些内存操作是 “读特性” （read-like）的，包括读、原子读、互斥锁加锁以及通道接收操作。其他内存操作是 “写特性” 的，包括写、原子写、互斥锁解锁、通道发送以及通道关闭操作。有些操作，比如CAS（atomic compare-and-swap），既是 类似“读特性” 的又是 “写特性” 的。



一个goroutine执行被建模为单个goroutine所执行的一组内存操作。

要求1：给定从内存读取和写入的值，每个goroutine中的内存操作必须对应于该goroutin的正确顺序执行；该执行必须与"sequenced before"（顺序在前）关系保持一致，这个部分顺序的要求（the partial order requirements）在Go语言规范（Go language specification）或者表达式求值顺序（order of evaluation for expressions）中被定义为 Go的控制流结构；

Go 程序执行被抽象为一组 goroutine 的执行，以及一个抽象映射 W：表示每个读特性的操作都用来读取的写特性的操作；（同一个程序的多次执行可以由不同的程序执行）；



要求2：对于一个给定的执行执行，当把映射w限定在同步操作范围内时，必须以某种隐含的同步操作的一致性顺序来解释。该操作必须（与代码）顺序一致，并且（每一个操作执行后的）值是由这些操作读取和修改的值；

synchronized before（操作前同步）关系源自映射 W，并且是一个同步内存操作基础上的部分有序操作。

如果一个同步的"read like"内存操作r观察到一个同步的"write-like"的内存操作w（即W(r) = w），此时w就需要在r执行前被同步。

不严格的讲，刚才提到的 synchronized before（操作前同步）操作是前文中提到的全局顺序执行的一个子集，原因主要是受限于映射 W 所能直接观察到的信息；



要求3： 对于一个普通（非同步）的在内存地址 x 上的读取操作 r，W(r) 操作也必须要保证，写入操作 w 对于读取操作 r 是可见的，这里的可见性主要包括两点：

写入操作 w 操作发生在读取操作 r 之前；

写入操作 w 不会发生在读取操作 r 之前的任何其他写入 w’（至 x）之前；



一个在内存地址x上的读写data race，主要包括：一个在内存x处的读特性操作r和一个对同一地址下的写操作w，并且俩者只有有一个没有进行同步操作，最终导致了无序的happens before。（即：即不能保证 r 在 w 之前执行，也不能保证 w 在 r 之前执行）；

一个在内存地址为 x 上的 写写data race，主要包括：两个在内存 x 处的写特性操作 w 和 w‘，并且两者至少有一个没有进行同步操作，最终就导致了无序的 happens before；

注意到：如果在内存 x 处没有 读写或写写data race，那么此时任何读操作 r 都只会有一个唯一确定的 W(r)：一个紧跟着的 w 操作；

更一般的结论：任何一个 data-race-free 的 Go 程序都表示其不存在 read-write 或 write-write data race，并且都可以被唯一的被解释为一些顺序一致的被交织在许多 goroutine 中的执行过程（这一点和前面提到的 Boehm 和 Adve 论文中的第七小节中的证明完全一致！），这个性质就被称为 DRF-SC；

更加广义化的 DRF-SC 的定义的目的是为其他编程语言提供了 race-free 编程的实现，包括：C, C++, Java, JavaScript, Rust, 和 Swift等；

某些 Go 中的操作例如：创建 goroutine、内存分配等，都表现为同步操作（内部实现）；

这些操作对于“在同步操作前保证局部顺序”（synchronized-before partial order）在下面的 Synchronization 小节会详细讲述。此外，每个独立的库都有责任为自己提供的操作提供相应的类似的文档。



### 含有data-race的代码实现的限制

前面的内容给出了 data-race-free 程序执行的定义；本节主要是讲述为那些实现必须为包含 data-race 的程序所必须提供的语义；

首先，（Go 提供了相关工具使得）任何代码实现都可以在检测到 data race 之后报告 race 内容，并且停止执行程序；这个特性主要是通过 ThreadSanitizer （可以使用 “go build -race”）来实现的；

否则，对于一个在读取内存地址为 x 且大小不超过一个机器字长的操作，必须能够观测到在这个读操作之前的一个写操作 w，同时在这个 w 和 r 之间不能插入另外一个写操作 w‘ 使得 w 在 w‘ 之前执行，而 w‘ 在 r 之前执行！

即：（同步操作应该保证）每个读取操作都应当能够观测到在他之前或者并发执行的写操作的值！

> 这里解释一下：
>
> 为什么读取操作会看不到在他之前执行的写操作的值：
>
> 在现代 CPU 架构中，基本上都会存在多级的 CPU Cache 来缓存，这样避免了所有的操作都要去访问内存空间，但是也导致了一个显然的问题：
>
> 由于CPU存在多个核，某个核中的数据可能不会立即刷入到内存中，这就导致了如果其他CPU核心去内存中取值，取到的是旧的值，而非 CPU Cache 中的值！
>
> Go 中的同步原语，如：lock、channel、atomic 都保证了 Cache 中的值能够在多个 goroutine 中可见（刷入内存中），这也是上面的内容讲的；
>
> 对于 Java、C++ 等语言，还提供了类似 volatile 的关键字，保证变量直接被刷入内存，以确保对其他线程的可用性；
>
> 关于不大于一个字长的定义：
>
> 对于大于一个字长的结构，通常其空间都是在堆上分配，而在操作时都是通过一个机器字长的指针进行操作；
>
> 所以这里关注的都是不大于一个字长的定义，而通常对于这些数据，拷贝他们的值消耗的性能，和移动他们的值消耗的性能几乎没什么区别，例如：int类型；

此外，观察到未分配空间的（acausal，无配偶的）和未初始化完成的对象（“out of thin air”）的写入是不允许的；

我们鼓励读取超过一个机器字长的内存空间的操作，但是他的语义和单机器字长的场景有所不同：观察单个允许写入w；

出于性能方面的考虑，在真正实现时，超过一个机器字长的内存空间的操作可能被处理为多个独立的单机器字长的无序操作。这表示多字长的数据上的 data race 可能会导致数据的不一致性，这和（之前）单个的写入操作（的表现）不同；

当某个复杂类型的取值依靠：内部实现（指针，长度）或者数据对（指针，类型）时，例如：map、slice、string 在 Go 中的实现，这样的数据竞争会导致内存中的数据损坏（memory corruption），出现不一致；

下面的“不正确同步”（“Incorrect synchronization”）小节给出了错误同步的代码例子；下面的“错误编译”（“Incorrect compilation”）小节给出了data race 实现限制的代码例子；



























这篇文章主要讲了在并发等复杂场景下，程序内存操作的顺序、数据的可见性要符合合理的规则，这些规则就是Go内存模型。

内存操作：读取变量、赋值变量。

同步操作：Go的原子操作（atomic包），互斥锁和Channel都是实现并发下的数据同步。



Required1讲的是goroutine中代码的执行要按照正确的顺序执行执行，这部分要遵循Go语言规范定义。

```go
package main

import "fmt"

func main() {
    var x int
    go func() {
        // 按照代码顺序，不可能出现先打印再赋值的情况。
        x = 5
        fmt.Println(x)
    }()
}
```

Required2讲的是，程序中的同步操作，它们存在着一种隐含着的总的先后顺序。比如通过通道来传递数据，发送数据和接收数据的操作肯定要有个先后顺序；用互斥锁的话，加锁、访问共享资源、解锁着几个操作也有顺序要求。比如下面的代码：

```go
package main

import (
    "sync"
    "fmt"
)

var mutex sync.Mutex
var sharedValue int

func writer() {
    mutex.Lock()
    sharedValue = 10
    mutex.Unlock()
}

func reader() {
    mutex.Lock()
    value := sharedValue
    mutex.Unlock()
    fmt.Println(value)
}

func main() {
    go writer()
    go reader()
    // 可以添加等待协程执行完的代码，这里简化了
}
```

Required3主要讲了，对于普通数据的读取操作（不是同步操作场景），要保证它读取到的值是正确的。要做到这点就要保证另外一个写操作对数据的修改对于读操作来说是可见的，即满足俩点要求：

- 写操作先于读操作发生
- 该写操作与读操作之间未发生任何其他写操作。







